<!DOCTYPE html>
<html>

<head>
  <title>Canvas Example</title>
  <style>
    #layer1,
    #layer2 {
      position: absolute;
      top: 0;
      left: 0;
    }
    #layer1 {
      z-index: -1;
    }
  </style>
</head>

<body onload="layer1(); layer2()">
  <canvas id="layer1" width="400" height="400"></canvas>
  <canvas id="layer2" width="400" height="400"></canvas>
  <script>

    var scale
    const X = 370  // X shift in pixels
    const Y = 30 // Y shift in pixels
    function layer1() {
      // measurements
      var w = [] // joist spacing in inches
      const a =[0,253,561,863,1164,1471,1777,2087,2389,2693,2992,3306]
      var s = 2.75 // wall strip in inches
      for (let i =1; i <a.length; i++){
        w[i-1] = (a[i]-a[i-1]) / 25.4
      }
      //var w = [12, 12, 14, 5] // joist spacing in inches
      var depth = 7.25 // trough depth in inches
      var L = 112 // trough length in inches
      var sw = (3473 -3306)/25.4 +1.75 // outer strip width in inches

      // Calculate angle, base
      var b = [] // trough base in inches
      var θ = [] // trough anle
      console.log('#  width   base  theta[deg] ')
      var Θtotal = 0
      for (let i = 0; i < w.length; i++) {
        b[i] = 2 * Math.sqrt(depth ** 2 + ((w[i] - 3)/2) ** 2) + 3
        θ[i] = 2 * Math.atan((b[i] / 2 - w[i] / 2) / L)
        deg = θ[i] * 180 / Math.PI
        Θtotal += deg
        console.log((i+1) + '  ' + w[i] + '  ' + b[i].toFixed(2) + '  ' + deg.toFixed(2))
      }
      var r = w[0] / 2 / Math.sin(θ[0]/2)
      R = b[0] / 2 / Math.sin(θ[0] / 2)
      console.log('radius: ' + R.toFixed(2) + ' in')
      console.log('total angle: ' + Θtotal.toFixed(2) + ' deg')

      // Set canvas size to match screen width
      var canvas = document.getElementById("layer1");
      var ctx = canvas.getContext("2d");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      var maxRadius = Math.min(canvas.width, canvas.height)-50

      // scale inches to pixels
      scale = maxRadius / R /1.1
      console.log('trough length =' + L.toFixed(0) + ' in')
      L *= scale
      console.log('trough length =' + L.toFixed(0) + ' pixels, scale=' + scale.toFixed(2) + '\n ')
      r *= scale
      R *= scale
      sw *= scale
      console.log('radius: ' + R.toFixed(0) + ' pixels')
      for (let i = 0; i < w.length; i++) {
        w[i] *= scale
        b[i] *= scale
      }

      // Draw a circle
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.arc(X, Y, R, 0, 2 * Math.PI);
      ctx.stroke();

      // draw strip
      s *= -scale
      drawDashedLine(0, 0, r, 0)
      drawLine(r, 0, R, 0)
      drawLine(r, 0, r, s)
      drawLine(R, 0, R, s)
      drawLine(r, s, R, s)

      // draw spokes
      drawDashedLine(0, 0, r, 0)
      drawLine(r, 0, R, 0)
      var angle = 0
      prevAngle = 0;
      var x
      var y
      var x2
      var y2
      for (let i = 0; i < w.length; i++) {
        angle = angle + θ[i]
        x = r * Math.cos(angle);
        y = r * Math.sin(angle);
        drawDashedLine(0, 0, x, y)
        ctx.font = "30px Arial";
        ctx.fillText(i+1, X+x, Y+y);
        x2 = R * Math.cos(angle);
        y2 = R * Math.sin(angle);
        drawLine(x, y, x2, y2)
        drawPerpicularLines(prevAngle, angle, r, R)
        prevAngle = angle
      }

      // draw strip
      xs = x - sw * Math.sin(prevAngle)
      ys = y + sw * Math.cos(prevAngle)
      x2s = x2 - sw * Math.sin(prevAngle)
      y2s = y2 + sw * Math.cos(prevAngle)
      drawLine(x, y, xs, ys)
      drawLine(x2, y2, x2s, y2s)
      drawLine(xs, ys, x2s, y2s)

      function drawPerpicularLines(theta1, theta2, r, R) {
        drawPerpicularLine(theta1, theta2, r)
        drawPerpicularLine(theta1, theta2, R)
      }

      function drawPerpicularLine(theta1, theta2, r) {
        x1 = r * Math.cos(theta1)
        y1 = r * Math.sin(theta1)
        x2 = r * Math.cos(theta2)
        y2 = r * Math.sin(theta2)
        drawLine(x1, y1, x2, y2)
      }
      function drawLine(x1, y1, x2, y2) {
        ctx.beginPath();
        ctx.strokeStyle = '#0000ff';
        ctx.setLineDash([0,0]);
        ctx.moveTo(x1+X, y1+Y);
        ctx.lineTo(x2+X, y2+Y);
        ctx.stroke();// measurements
      }
      function drawDashedLine(x1, y1, x2, y2) {
        ctx.beginPath();
        ctx.setLineDash([2, 2]);
        ctx.moveTo(x1+X, y1+Y);
        ctx.lineTo(x2+X, y2+Y);
        ctx.stroke();// measurements
      }

    }

    var theta = 1.26;
    var w;
    var h;
    var xc = 266;
    var yc = 284;
    function layer2() {
       // Membrane measurements
      w = 20 * 12  // inches
      h = 10 * 12 // inches

      console.log('Membrane w,h ' + w .toFixed(2)+ ', ' + h.toFixed(2) + ' in')

      w *= scale
      h *= scale
      console.log('Membrane w,h ' + w.toFixed(0) + ', ' + h.toFixed(0) + ' pixels\n ')

      var canvas2 = document.getElementById("layer2");
      var ctx2 = canvas2.getContext("2d");
      canvas2.width = window.innerWidth;
      canvas2.height = window.innerHeight;

      // Draw a rectangle
      drawRectangle(w, h);
      function drawRectangle(w, h) {
        p0 = rotatePt(-w/2, h/2, theta)
        p2 = rotatePt(w/2, h/2, theta)
        drawLine(X+xc + p0[0], Y+yc + p0[1], X+xc + p2[0], Y+yc + p2[1]);
        p1 = p2;
        p2 = rotatePt(w/2, -h/2, theta)
        drawLine(X+xc + p1[0], Y+yc + p1[1], X+xc + p2[0], Y+yc + p2[1]);
        p1 = p2;
        p2 = rotatePt(-w/2, -h/2, theta)
        drawLine(X+xc + p1[0], Y+yc + p1[1], X+xc + p2[0], Y+yc + p2[1]);
        drawLine(X+xc + p2[0], Y+yc + p2[1], X+xc + p0[0], Y+yc + p0[1]);

      }
      function rotatePt(x, y, theta) {
        x2 = x * Math.cos(theta) + y * Math.sin(theta)
        y2 = y * Math.cos(theta) - x * Math.sin(theta)
        return [x2, y2]
      }
      function drawLine(x1, y1, x2, y2) {
        ctx2.beginPath();
        ctx2.strokeStyle = '#ff0000';
        ctx2.moveTo(x1, y1);
        ctx2.lineTo(x2, y2);
        ctx2.stroke();
      }
    }

    let rotation = 0;
    var isDragging;
    function handleMouseWheel(event) {
      theta += event.deltaY * 0.0001;
      console.log('.... theta= ' + theta
      )
      layer2();
    }
    document.getElementById("layer2").addEventListener("wheel", handleMouseWheel);

    function handleKeyDown(event) {
      const d = 2;
      switch (event.keyCode) {
        case 37: // left arrow key
          xc -= d;
          break;
        case 39: // right arrow key
          xc += d;
          break;
        case 38: // left up key
          yc -= d;
          break;
        case 40: // right down key
          yc += d;
          break;
      }
      console.log('-|--|- rect xc, yc= ' + xc + ', ' + yc)
      layer2();
    }
    window.addEventListener("keydown", handleKeyDown);

    var clickCount = 1
    var x1
    var y1
    window.addEventListener("click", function(event) {
      var canvas2 = document.getElementById("layer2");
      var ctx = canvas2.getContext("2d");
      const x = event.clientX;
      const y = event.clientY;
      ctx.beginPath();
      if (clickCount==3) {
         ctx.clearRect(0, 0, 300, 150);
         clickCount = 0
      } else {
        const x = event.clientX;
        const y = event.clientY;
        ctx.moveTo(x - 10, y);
        ctx.lineTo(x + 10, y);
        ctx.moveTo(x, y - 10);
        ctx.lineTo(x, y + 10);
        ctx.font = "20px Arial";
        ctx.fillText(`${clickCount}  (${x.toFixed(0)}, ${y.toFixed(0)})`, 10, 40*clickCount);
       if (clickCount==2) {
           d = Math.sqrt((x1-x)**2+ (y1-y)**2)
           inches = d/scale
           mm = inches * 25.4
           ctx.fillText(`d = ${d.toFixed(1)}  ${inches.toFixed(1)} in, ${mm.toFixed(0)} mm`, 10, 40*3);
        } else {
           x1 = x;
           y1 = y;
        }
      }
      ctx.stroke();
      clickCount++;

    });


    window.onresize = function () {
      layer1();
      layer2();
    }
  </script>
</body>

</html>
